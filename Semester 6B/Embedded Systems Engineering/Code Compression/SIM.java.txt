/*
 * Click nbfs://nbhost/SystemFileSystem/Templates/Licenses/license-default.txt to change this license
 * Click nbfs://nbhost/SystemFileSystem/Templates/Classes/Main.java to edit this template
 */
package sim;

/**
 *
 * @author Nuwan Bandara - 180066F
 */

//EN3240 - Assignment 3
/* On my honor, I have neither given nor received unauthorized aid on this assignment */

import java.io.*;                                                               //import java classes which are mainly to file handling and linked mapping 
import java.util.*;
import java.nio.file.*;
import java.util.Map;
import java.util.Map.Entry;
import java.util.HashMap;
import java.util.Iterator;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.stream.Collectors;

public class SIM {
    //java mapping-based implementation
    static LinkedHashMap<String, Integer> instruction_map = new LinkedHashMap<>();      //Maps to build key/value pairs    
    static List<String> instruction_list = new ArrayList<>();
    static List<String> com_list = new ArrayList<>();
    static LinkedHashMap<String, Integer> dictionary = new LinkedHashMap<>();
    static LinkedHashMap<Integer, String> dictionary_reversed = new LinkedHashMap<>();
    static HashMap<String, Integer> length_from_format = new HashMap<>();
    
    static int RLE = 0;
    static String decom_string = "";
    static int i;
    
    static String com_instruction_all = "";                                            //compression (com) binaries all
    static String decom_instruction = "";                                              //decompression (decom) binaries all

    public static void main(String[] args) {
        String com_or_decom = args[0];                                          //Obtain selection from input arguments 
        switch (com_or_decom) {
            case "1" -> compression();
            case "2" -> decompression();
            default -> System.out.println("Please enter a valid number for compression (1) or decompression (2)");
        }
    }
    
/*"""""""""""""""""""""""""""""""""""""""""""""""""""'Compression implementation"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""*/
    public static void compression(){
        
        String instruction_line;
        String prev_instruction = "invalid";
        String file_name = null;
        
        file_name = "original.txt";                                             //input file for compression
        File file = new File(file_name);
        
        try{
                BufferedReader br = new BufferedReader(new FileReader(file));   //read content of the file and get binaries
                while ((instruction_line = br.readLine()) != null){
                        instruction_list.add(instruction_line);
                        if(instruction_map.containsKey(instruction_line)){
                                instruction_map.put(instruction_line, instruction_map.get(instruction_line) + 1);
                        } else{
                                instruction_map.put(instruction_line, 1);					
                        }
                }
            
        } catch(Throwable e ){
                e.printStackTrace();
        }
        
        dictionary = acquire_top_eight_through_value(instruction_map);
        
		for(i=0; i<instruction_list.size(); i++){                              //iterate through binaries
			String com_inst_line = "";
			instruction_line = instruction_list.get(i);
			if(instruction_line.equals(prev_instruction)){
				RLE++;
			} else{                                                 //instruction is new
				if(RLE>1){                                      //check whether it would be run-length encoding (RLE)
					occurance_RLE();                            //if it is RLE, print previous (RLE-1) instructions
					RLE = 0;
					com_instruction_all = com_instruction_all;            
				}
				if(dictionary.containsKey(instruction_line)){          //direct matching
					int dict_index = dictionary.get(instruction_line);
					com_inst_line = String.format("%3s", Integer.toBinaryString(dict_index)).replace(' ', '0');
                                        com_instruction_all = com_instruction_all + "101" + com_inst_line;
				} 
				else if(!((com_inst_line = one_bit_mismatch_checking(instruction_line)).equals(""))){// 1-bit mismatch
					com_instruction_all = com_instruction_all + "010" + com_inst_line;
				} 
				else if(!((com_inst_line = two_bits_mismatch_checking(instruction_line)).equals(""))){// 2-bit consecutive mismatch
					com_instruction_all = com_instruction_all + "011" + com_inst_line;
				} 
				else if(!((com_inst_line = bit_mask_checking(instruction_line)).equals(""))){       // bit mask compression
					com_instruction_all = com_instruction_all + "001" + com_inst_line;
				} 
				else if(!((com_inst_line = two_bits_at_anylocation_checking(instruction_line)).equals(""))){// 2-bit mismatch at any location
					com_instruction_all = com_instruction_all + "100" + com_inst_line;
				} 
				else {                                                                  // binary is if_original
					com_instruction_all = com_instruction_all + "110" + instruction_line;
				}
				RLE = 1;
				prev_instruction = instruction_line;
			}
		}
		String com = String.format("%-" + ((com_instruction_all.length()/32)+1)*32 + "s", com_instruction_all).replace(' ', '1');
		String parsed_string = com.replaceAll("(.{32})", "$1\n").trim();
		try{
			PrintStream file_stream = new PrintStream("cout.txt");  //output compressed txt
			System.setOut(file_stream);
		} catch(Throwable e ){                                          //to catch any error during writing
			e.printStackTrace();
		} 
		System.out.println(parsed_string);
		System.out.println("xxxx");                                     //to seperate eight dictionary entries from compressed patterns
        Iterator itert = dictionary.entrySet().iterator();
        while(itert.hasNext()){
            Map.Entry pair = (Map.Entry)itert.next();
            System.out.println(pair.getKey());      
        }
	}

	public static String int_to_string(int dict_index, int strLength){      //to be able to save in the decom_string txt
		String dict_index_S = String.format("%3s", Integer.toBinaryString(dict_index)).replace(' ', '0');
		return dict_index_S;
	}
        
        private static boolean bit_value(char in) {                                //acquire bit from char
	    return (in == '1');
	}
	private static char char_value(boolean in) {                               //acquire char from boolean
	    return (in) ? '1' : '0';
	}
        
        public static String cyclic_shift_to_left(String s, int m){             //to facilitate cyclic left shift in any location
		m = m%s.length();
		return s.substring(m) + s.substring(0, m);
	}

        public static LinkedHashMap<String, Integer> acquire_top_eight_through_value(LinkedHashMap<String, Integer> map) { 
            AtomicInteger index = new AtomicInteger();                          //hashmap for key and entry mapping
            return map.entrySet().stream()
                    .sorted(Entry.<String, Integer> comparingByValue().reversed())
                    .limit(8)
                    .collect(
                    Collectors.toMap(
                            e -> e.getKey(),
                            e -> index.getAndIncrement(),
                            (k, v) -> {
                            throw new IllegalStateException("duplicate key " + k);
                            },
                            LinkedHashMap::new)
                );
        }

	public static void occurance_RLE(){                                         //run length encoding print considering compression instruction
		String com_instruction = "";
		switch (RLE){
			case 2: com_instruction = "00";
					break;
			case 3: com_instruction = "01";
					break;
			case 4: com_instruction = "10";
					break;
			case 5: com_instruction = "11";
					break;			
		}
		com_instruction_all = com_instruction_all + "000" + com_instruction;
	}

	public static String one_bit_mismatch_checking(String instruction_line){          //1-bit mismatch
		for(int h=0; h<instruction_line.length(); h++){
			StringBuilder instruction_line_sb = new StringBuilder(instruction_line);
			instruction_line_sb.setCharAt(h, instruction_line_sb.charAt(h)=='0' ? '1':'0'); //1-bit mismatch checking
			String instruction = instruction_line_sb.toString();
			if(dictionary.containsKey(instruction)){                //return compressed format
				String mismatch_location = String.format("%5s", Integer.toBinaryString(h)).replace(' ', '0'); 
				int dict_index = dictionary.get(instruction);
				String dict_index_string = int_to_string(dict_index, 3);
				return mismatch_location + dict_index_string;
			}
		}
		return "";
	}

	public static String two_bits_mismatch_checking(String instruction_line){          //2-bit consecutive mismatch
		for(int h=0; h<instruction_line.length()-1; h++){
			StringBuilder instruction_line_sb = new StringBuilder(instruction_line);
			if(instruction_line_sb.charAt(h) == '0' && instruction_line_sb.charAt(h+1) == '0'){ //2-bit mismatch checking
				instruction_line_sb.setCharAt(h, '1');
				instruction_line_sb.setCharAt(h+1, '1');
			} else if(instruction_line_sb.charAt(h) == '0' && instruction_line_sb.charAt(h+1) == '1'){
				instruction_line_sb.setCharAt(h, '1');
				instruction_line_sb.setCharAt(h+1, '0');
			} else if(instruction_line_sb.charAt(h) == '1' && instruction_line_sb.charAt(h+1) == '0'){
				instruction_line_sb.setCharAt(h, '0');
				instruction_line_sb.setCharAt(h+1, '1');
			} else {
				instruction_line_sb.setCharAt(h, '0');
				instruction_line_sb.setCharAt(h+1, '0');
			}
			String instruction = instruction_line_sb.toString();
			if(dictionary.containsKey(instruction)){                //return compressed format
				int dict_index = dictionary.get(instruction);
				String dict_index_string = int_to_string(dict_index, 3);
				String mismatch_location = String.format("%5s", Integer.toBinaryString(h)).replace(' ', '0');
				return mismatch_location + dict_index_string;
			}
		}
		return "";
	}

	public static String bit_mask_checking(String instruction_line){                  // bit mask compression
		for(int n=8; n<16; n++){
			String mask_small = String.format("%4s", Integer.toBinaryString(n)).replace(' ', '0');
			for(int q=0; q<29; q++){
				StringBuilder instruction_line_sb = new StringBuilder();
				String pad_left_with_zeros = String.format("%" + (q+4) + "s", mask_small).replace(' ', '0');        //pad with zeros to the left
				String mask = String.format("%-" + 32 + "s", pad_left_with_zeros ).replace(' ', '0');
				for(int j=0; j<32; j++){
					instruction_line_sb.append(char_value(bit_value(mask.charAt(j)) ^ bit_value(instruction_line.charAt(j))));         //bit-wise XOR
				}
				String instruction = instruction_line_sb.toString();
				if(dictionary.containsKey(instruction)){        //retun compressed format
					int dict_index = dictionary.get(instruction);
					String dict_index_string = int_to_string(dict_index, 3);
					String mismatch_location = String.format("%5s", Integer.toBinaryString(q)).replace(' ', '0');
					return  mismatch_location + mask_small + dict_index_string;
				}
			}
		}
		return "";
	}
	
	
	public static String two_bits_at_anylocation_checking(String instruction_line){      // 2-bit mismatch at any location
		String mask_left_bit = "10000000000000000000000000000000";
		String mask_right_bit = "01000000000000000000000000000000";
		for(int i=0; i<31; i++){
			String left_mask = cyclic_shift_to_left(mask_left_bit, (32-i));
			for(int j=i+1; j<32; j++){
				StringBuilder mask_sb = new StringBuilder();
				StringBuilder instruction_line_sb = new StringBuilder();
				String right_mask = cyclic_shift_to_left(mask_left_bit, (32-j));            //cyclic shift to cover any location
				for(int h=0; h<32; h++){
					mask_sb.append(char_value(bit_value(left_mask.charAt(h)) ^ bit_value(right_mask.charAt(h))));        //bit-wise XOR
					instruction_line_sb.append(char_value(bit_value(mask_sb.charAt(h)) ^ bit_value(instruction_line.charAt(h))));
				}
				String instruction = instruction_line_sb.toString();
				if(dictionary.containsKey(instruction)){        //return compressed format
					int dict_index = dictionary.get(instruction);
					String dict_index_string = int_to_string(dict_index, 3);
					String mismatch_location_left = String.format("%5s", Integer.toBinaryString(i)).replace(' ', '0');
					String mismatch_location_right = String.format("%5s", Integer.toBinaryString(j)).replace(' ', '0');
					return  mismatch_location_left +  mismatch_location_right +  dict_index_string;
				}
			}
		}
		return "";
	}

//*""""""""""""""""""""""""""""""""""""""""""""""""Decompression implementation"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""*/        
	public static void decompression(){
		String dict = "";
		String format = "";
		String com_instruction = "";
		int instruction_length = 0;
                
                String file_name = "compressed.txt";                            //input file for decompression
		File file = new File(file_name);
		
                i = 0;
                
		try{
			com_instruction_all = new String(Files.readAllBytes(Paths.get(file_name))); //read from the file 
		} catch(Throwable e ){
			e.printStackTrace();
		}
                
		dict = com_instruction_all.substring(com_instruction_all.lastIndexOf("x") + 1).trim(); //dictionary build
		String lines[] = dict.split("\\r?\\n");
		for(i=0; i<lines.length; i++){
			dictionary_reversed.put(i, lines[i]);
		}
		i=0;

		length_from_format.put("000", 2);                                 //format to instruction length dictionary implementation; RLE 2-bits
		length_from_format.put("001", 12);                                //bitmask compression - 12 bits (starting location_5+bitmask_4+dictionary index_3)
		length_from_format.put("010", 8);                                 //1-bit mismatch (starting location_5+dictionary index_3)
		length_from_format.put("011", 8);                                 //2-bits consecutive mismatch (starting location_5+dictionary index_3)
		length_from_format.put("100", 13);                                //2-bits mismatch any location (1st mismatch location_5+2nd mismatch location_5+dictionary index_3)
		length_from_format.put("101", 3);                                 //direct matching (dictionary index_3)
		length_from_format.put("110", 32);                                //original binary (original_32)
		
                com_instruction_all = com_instruction_all.replaceAll("\\r\\n|\\r|\\n", "");
                
		while(com_instruction_all.charAt(i) != 'x'){                           //to find the format through compressed string

			format = acquire_format();                                  //first 3 bits which relate to the compression type
			if(length_from_format.containsKey(format)){               
				instruction_length = length_from_format.get(format);
			} else {
				break;
			}

			StringBuilder sb = new StringBuilder();                 //corresponding bits with respect to that compression instruction type
			for(int j=0; j<instruction_length; j++){
				sb.append(com_instruction_all.charAt(i++));
			}
			com_instruction = sb.toString();
			if(format.equals("000")){                               //direct binary to correct decompression with respect to first 3-bits (which indicate the compression type)
				decom_instruction = if_run_length_enco(com_instruction);
			} else if(format.equals("001")){
				decom_instruction = if_bit_mask(com_instruction);
			} else if(format.equals("010")){
				decom_instruction = if_one_bit_mismatch(com_instruction);
			} else if(format.equals("011")){
				decom_instruction = if_two_bits_mismatch(com_instruction);
			} else if(format.equals("100")){
				decom_instruction = if_two_bits_mismatch_at_anylocation(com_instruction);
			} else if(format.equals("101")){
				decom_instruction = if_direct_match(com_instruction);
			} else if(format.equals("110")){
				decom_instruction = if_original(com_instruction);
			}
		}
		String parsed_string = decom_string.replaceAll("(.{32})", "$1\n").trim();
		try{
			PrintStream file_stream = new PrintStream("dout.txt");          //output file through decompression
			System.setOut(file_stream);
		} catch(Throwable e ){
			e.printStackTrace();
		} 
		System.out.println(parsed_string);
	}
        
        public static String acquire_format(){                                      //first 3 bits which relate to the compression type
		StringBuilder f = new StringBuilder();
		for(int j=0; j<3; j++){
			f.append(com_instruction_all.charAt(i++));
		}
		return f.toString();
	} 
        
        public static String if_direct_match(String com_instruction){                     //direct match incident
		String dict_index = com_instruction.substring(0, com_instruction.length());
		int dict_index_int = Integer.parseInt(dict_index, 2);
		if(dictionary_reversed.containsKey(dict_index_int)){
			decom_instruction = dictionary_reversed.get(dict_index_int);      //decompression generation according to direct matching
		}
		decom_string = decom_string + decom_instruction;                                   //decompressed binary adding to overall decom_string 
		return decom_instruction;
	}

	public static String if_original(String com_instruction){                         //original binary incident
		decom_instruction = com_instruction;
		decom_string = decom_string + decom_instruction;
		return decom_instruction;
	}

	public static String if_run_length_enco(String com_instruction){                  //run-length encoding incident
		if(com_instruction.equals("00")){                                      //in accordance with the number of occurance
			decom_string = decom_string + decom_instruction;
		} else if(com_instruction.equals("01")){
			decom_string = decom_string + decom_instruction + decom_instruction;
		} else if(com_instruction.equals("10")){
			decom_string = decom_string + decom_instruction + decom_instruction + decom_instruction;
		} else if(com_instruction.equals("11")){
			decom_string = decom_string + decom_instruction + decom_instruction + decom_instruction + decom_instruction;
		}
		return decom_instruction;
	}

	public static String if_bit_mask(String com_instruction){                         //bit-mask incident
		String mismatch_location = com_instruction.substring(0,5);             //mismatch location, bitmask and dictionary index through binary sequence
		String bit_mask = com_instruction.substring(5,9);
		String dict_index = com_instruction.substring(9, com_instruction.length());
		int dict_index_int = Integer.parseInt(dict_index, 2);
		String instruction = "";
		if(dictionary_reversed.containsKey(dict_index_int)){
			instruction = dictionary_reversed.get(dict_index_int);
		}
		int mismatch_location_int = Integer.parseInt(mismatch_location, 2);
		StringBuilder instruction_sb = new StringBuilder();
		String pad_zeros_to_left = String.format("%" + (mismatch_location_int+4) + "s", bit_mask).replace(' ', '0');
		String mask = String.format("%-" + 32 + "s", pad_zeros_to_left ).replace(' ', '0');
		for(int j=0; j<32; j++){
			instruction_sb.append(char_value(bit_value(mask.charAt(j)) ^ bit_value(instruction.charAt(j)))); //bitwise XOR for regenerating the if_original
		}
		decom_instruction = instruction_sb.toString();
		decom_string = decom_string + decom_instruction;
		return decom_instruction;
	}

	public static String if_one_bit_mismatch(String com_instruction){                 //1-bit mismatch incident
		String mismatch_location = com_instruction.substring(0,5);             //1-bit masmatch location and dictionary index
		String dict_index = com_instruction.substring(5, com_instruction.length());
		int dict_index_int = Integer.parseInt(dict_index, 2);
		String instruction = "";
		if(dictionary_reversed.containsKey(dict_index_int)){
			instruction = dictionary_reversed.get(dict_index_int);
		}
		int mismatch_location_int = Integer.parseInt(mismatch_location, 2);
		StringBuilder instruction_sb = new StringBuilder(instruction);		
		instruction_sb.setCharAt(mismatch_location_int, instruction_sb.charAt(mismatch_location_int)=='0' ? '1':'0'); //generate if_original from 1-bit mismatch
		decom_instruction = instruction_sb.toString();
		decom_string = decom_string + decom_instruction;
		return decom_instruction;
	}

	public static String if_two_bits_mismatch(String com_instruction){                //2-bits consecutive mismatch incident
		String mismatch_location = com_instruction.substring(0,5);             //2-bits consecutive mismatch location and dictionary index
		String dict_index = com_instruction.substring(5, com_instruction.length());
		int dict_index_int = Integer.parseInt(dict_index, 2);
		String instruction = "";
		if(dictionary_reversed.containsKey(dict_index_int)){
			instruction = dictionary_reversed.get(dict_index_int);
		}
		int mismatch_location_int = Integer.parseInt(mismatch_location, 2);
		StringBuilder instruction_sb = new StringBuilder(instruction);	
		instruction_sb.setCharAt(mismatch_location_int, instruction_sb.charAt(mismatch_location_int)=='0' ? '1':'0'); //generate if_original from 2 consecutive mismatches
		instruction_sb.setCharAt(mismatch_location_int+1, instruction_sb.charAt(mismatch_location_int+1)=='0' ? '1':'0');
		decom_instruction = instruction_sb.toString();
		decom_string = decom_string + decom_instruction;
		return decom_instruction;
	}

	public static String if_two_bits_mismatch_at_anylocation(String com_instruction){    //2-bits mismatch at any location incident
		String mismatch_location_left = com_instruction.substring(0,5);           //2-bits mismatch locations from left and right and dictionary index
		String mismatch_location_right = com_instruction.substring(5,10);
		String dict_index = com_instruction.substring(10, com_instruction.length());
		int dict_index_int = Integer.parseInt(dict_index, 2);
		String instruction = "";
		if(dictionary_reversed.containsKey(dict_index_int)){
			instruction = dictionary_reversed.get(dict_index_int);
		}
		int mismatch_location_left_int = Integer.parseInt(mismatch_location_left, 2);
		int mismatch_location_right_int = Integer.parseInt(mismatch_location_right, 2);
		StringBuilder instruction_sb = new StringBuilder(instruction);		
		instruction_sb.setCharAt(mismatch_location_left_int, instruction_sb.charAt(mismatch_location_left_int)=='0' ? '1':'0'); //generate if_original from left location mismatch
		instruction_sb.setCharAt(mismatch_location_right_int, instruction_sb.charAt(mismatch_location_right_int)=='0' ? '1':'0'); //generate if_original from right location mismatch
		decom_instruction = instruction_sb.toString();
		decom_string = decom_string + decom_instruction;
		return decom_instruction;
	}
}


